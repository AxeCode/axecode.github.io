---
layout: post
title: "进程描述和控制"
date: 2015-04-16 15:16:59 +0800
comments: true
categories: 技术
keywords: 进程,进程概念,进程状态,进程控制
---
> 进程概念是现在操作系统的基本概念，已经成为计算机科学中的一大成就。

## 什么是进程？

进程的出现，是为了是操作系统可以以一种有序的方式管理应用的执行，以达到以下目的：

+ 资源对多个应用程序是可用的
+ 物理处理器在多个应用程序之间切换以保证所有程序都在执行中
+ 处理器和I/O设备能得到充分利用

所有现在操作系统采用的方法都是依据一个或者多个进程存在的应用程序执行的一种模型。
到底什么是进程呢？

进程是一组元素组成的实体，它可以是一个正在执行中的程序，也可以是一个能分配给处理
器并由处理器执行的实体。进程的两个基本元素是：**程序代码(program code)**和代码相
关联的**数据集(set of data)**。在进程执行时，任意给定一个时间，进程都可以唯一地
表征为以下元素：

+ **标识符**：进程的唯一标识符，用来区别其他进程
+ **状态**：进程在不同的生命周期有着不同的状态
+ **优先级**：相对于其他进程的优先级
+ **程序计数器**：程序中即将被执行的下一条指令的地址
+ **内存指针**：包含程序代码和进程相关数据的指针，还有和其他进程共享内存块的指针
+ **I/O状态信息**：包括显示的I/O请求、分配给进程的I/O设备和被进程使用的文件列表等
+ **记账信息**：可能包括处理器时间总和、使用的时钟数总和、时间限制、记账号等

上述的列表信息被存放在一个称为**进程控制块**的数据结构中，该控制块由操作系统创建
和管理。

## 进程状态

在任何时刻，进程可以处于以下两种状态之一：运行态和未运行态，这是最简单的两状态模
型。在这个模型中，会有一个**调度器(dispatcher)**，使处理器从一个进程切换到另外一
个进程。

{% lazy_img lazy no-shadow /photos/state-transition.jpg 640 200 '内存状态转换' %}

由于存在着一些处于非运行状态但已经就绪等待执行的进程，而同时存在另外一些处于堵塞
状态等待I/O操作结束的进程。因此，解决这一问题比较自然的方法是使用五状态模型： **
运行态、就绪态、堵塞/等待态、新建态和退出态**。

{% lazy_img lazy no-shadow /photos/five-state-process-model.jpg 640 200 '五状态模型' %}

#### 被挂起的进程

上述的基本状态提供了一种为进程建立系统模型的方法，并指导系统的实现。但是，往这个
模型中添加其他状态也是合理的。

由于处理器的运行速度远大于I/O，以至于内存中所有的进程都在等待I/O的情况也是很常见
的。因此，即使是多道程序设计，大多数处理器仍然可能处于空闲状态。

一种解决方案是增大内存，使得内存中可以存在更多的进程。然而这种方案显然是治标不治
本的。

另外一种解决方案是**交换(swapping)**。当内存中没有处于就绪状态的进程时，操作系统
就把被阻塞的进程换出到磁盘中的**挂起队列(suspend queue)**。操作系统在此之后取出
挂起队列中的另一个进程，或者接受一个新进程，将其加载到内存中运行。这时，在进程状
态模型中添加了另外一个状态：**挂起态**。

{% lazy_img lazy no-shadow /photos/one-suspend-state.jpg 640 200 '单挂起态模型' %}

当操作系统从挂起队列中取出一个依然阻塞的进程是毫无意义的，因为它仍然没有准备好执
行。所以为了区分被挂起的进程哪些是可以取出的，需要设计另外一种挂起模型：

{% lazy_img lazy no-shadow /photos/with-two-suspend-state.jpg 640 200 '双挂起态模型' %}

为了区分，需要四个状态：

+ **就绪态**：进程在内存中并可以执行
+ **阻塞态**：进程在进程中并等待一个事件
+ **阻塞/挂起态**：进程在外存中并等待一个事件
+ **就绪/挂起态**：进程在外存中，但是只要被载入内存就可以执行

总结一下挂起的进程的概念：

1. 进程不能被立即执行。
2. 进程可能是或不是正在等待一个事件。如果是，阻塞条件不依赖于挂起条件，阻塞事件的
   的发生不会使进程立即执行。
3. 为组织进程的执行，可以通过代理把这个进程置于挂起状态，代理可以是进程自己，也
   可以是父进程或者操作系统。
4. 除非代理显示的命令操作系统进行状态转换，否则进程无法从这个状态中转移。

除了因为提供更多的内存空间，进程还会因为什么原因被挂起呢？

事件        |  说明
------------|--------
交换        |  操作系统需要释放更多的内存空间，以调入并执行处于就绪状态的进程
其他OS原因  |  操作系统可能挂起后台进程或工具程序进程，或者怀疑导致问题的进程
用户请求    |  用户可能希望挂起一个程序的执行，目的是为了调试或者与一个资源连接
定时        |  一个进程可能会周期性的执行，而且可能在等待下一个时间间隔时被挂起
父进程请求  |  父进程请求挂起后代进程，以检查或者修改挂起的进程

在所有这些导致进程挂起的情况中，挂起进程的活动都是由最初请求挂起的代理请求的。

## 进程描述

操作系统控制计算机系统内部的事件，它为处理器执行进程而进行调度「schedule」和分派
「dispatch」，给进程分配资源，并响应用户程序的基本服务请求。因此，操作系统可以被
视为管理系统资源的实体。

操作系统为了控制进程和管理资源需要哪些信息呢？

#### 操作系统的控制结构

为了管理进程和资源，操作系统构造并维护它所管理的每个实体的信息表。

{% lazy_img lazy no-shadow /photos/control-tables.jpg 640 200 '操作系统控制表的通用结构' %}

操作系统维护四种不同类型的表：**内存、I/O、文件和进程**。

内存表「memory tables」用于跟踪内存和外存。内存表必须包括一下信息：

+ 分配给进程的内存
+ 分配给进程的外存
+ 内存块或者虚拟内存块的保护属性
+ 管理虚拟内存所需要的任何信息

I/O表「I/O tables」用于管理计算机系统中的I/O设备和通道。在任何给定的时刻，一个I/O
设备或者是可用的，或者是已分配给某个特定的进程。如果正在进行I/O操作，则操作系统需
要知道I/O操作的状态和作为I/O传送的源与目标的内存单元。

文件表「file tables」用于提供关于文件是否存在、文件在外存中的位置、当前状态和属性
的信息。

进程表「process tables」为了管理和操作进程所必须使用的表。

#### 进程控制结构

操作系统在管理和控制进程时，首先必须知道进程的位置，然后，它必须知道在管理时所必
需的进程的属性（如进程ID、进程状态）。

##### 进程位置

想一个最基本的问题：进程的物理表示是什么？

回想之前关于进程的定义，进程至少包括一个或者一组被执行的程序，与这些程序相关联的
局部变量、全局变量和任何已定义常量的数据单元。因此，一个进程至少包括足够的内存空
间，以保存该进程的程序和数据；此外，程序的执行通常设计用于跟踪过程调用和过程间参
数传递的栈。最后，与每个进程相关联的还有操作系统用于控制进程的许多属性，也就是进
程控制块。程序、数据、栈和属性的集合称为**进程映像「process image」**。

在最简单的情况下，进程映像保存在邻近的活连续的存储块中。因此，操作系统必须知道每
个进程在磁盘中的位置；对于在内存中的进程，需要知道其在内存中的位置。

现代操作系统嘉定分页硬件允许用不连续的物理内存来支持部分常驻内存的程序。在任何给
定的时刻，进程映像的一部分可以在内存中，剩余部分可以在外存中。因此，操作系统维护
的进程表必须表明每个进程映像中每页的位置。

##### 进程属性

操作系统所需要的每个进程信息的简单分类：

+ 进程标识信息
+ 进程状态信息
+ 进程控制信息

{% lazy_img lazy no-shadow /photos/user-processes-in-virtual-memory.jpg 640 200 '虚拟内存中的用户进程' %}

所有的操作系统中，每个进程都分配了唯一的一个数字来表示**进程标识符**。除此之外，
还分配一个用户标识符，用于表明拥有该进程的用户。

**处理器状态信息**包括处理器寄存器的内容。当进程被中断时，所有寄存器中的信息必须
被保存起来，使得进程恢复执行时，这些信息可以被恢复。

进程控制块中的第三类主要信息是**进程控制信息**，用于操作系统控制和协调各种活动进
程所需要的额外信息。

进程控制块中可能还包含构造信息，包括将进程控制块链接起来的指针。

{% lazy_img lazy no-shadow /photos/process-list-structures.jpg 640 200 '进程链表结构' %}

##### 进程控制块的作用

进程控制块是操作系统中最重要的数据结构。操作系统中的每个模块，包括那些设计调度、
资源分配、中断处理、性能检测和分析的模块，都可能读取或者修改进程控制块。

## 进程控制

#### 执行模式

为了保护操作系统和重要的操作系统表不受用户程序的干涉，操作系统通常使用两种模式管
理进程：特权模式『也称为系统模式(system mode)、控制模式(control mode)或者内核模式
(kernel mode)』，和用户模式。

在内核模式下，软件具有对处理器及所有指令、寄存器和内存的控制能力，这一级的控制对
用户程序不是必需的，并且为了安全也不是用户程序可以访问的。

#### 进程创建

操作系统一般安装以下步骤创建进程：

1. 给进程分配一个唯一的进程标识符。此时，主进程表中增加一条新表项，其对应该进程。
2. 给进程分配空间。包括进程映像中的所有元素。
3. 初始化进程控制块。进程控制信息部分的初始化基于标准默认值和为该进程所请求的属
   性。
4. 设置正确的连接。
5. 创建或者扩充其他数据结构。

#### 进程切换

关于进程切换，有着一些问题。

+ 进程什么时候进程切换？
+ 执行模式切换和进程切换之间有什么区别？
+ 进程切换时，操作系统必须对它控制的各种数据结构做什么？

##### 何时切换进程

通常，下列原因可能造成进程切换。

机制      |  原因  |  用例
----------|--------|-----------------------------------------------------
中断      |  当前指令的外部执行    |  对异步外部事件的反映
陷阱      |  与当前指令的执行有关  |  处理一个错误或者异常
系统调用  |  显式请求              |  调用操作系统函数

##### 模式切换

如果存在一个未处理的中断，处理器会做以下工作：

+ 把程序计数器置成中断处理程序的开始地址。
+ 从用户模式切换到特权模式，使得中断处理代码可以包含有特权的指令。

##### 进程的状态变化

如果当前正在运行的进程被转换到另外一个状态（就绪、挂起等），则操作系统必须使其环
境发生实质性的变化：

1. 保存处理器的上下文环境，包括程序计数器和其他寄存器。
2. 更新当前处于运行态进程的进程控制块，包括将进程状态改变到另外一个状态。
3. 将进程的进程控制块移到相应的队列。
4. 选择另一个进程执行。
5. 更新所算则进程的进程控制块。
6. 更新内存管理的数据结构。
7. 恢复处理器在被选择的进程最近一次切换出运行状态时的上下文环境。
